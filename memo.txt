- 呼び出し先退避レジスタ
  rbx, rbp, rsp, r12-r15

- 呼び出し元退避レジスタ
  rax, rcx, rdx, rdi, rsi, r8-r11

- 戻り値用レジスタ
  rax
  rdx (２つ戻り値返す場合の二番目)

- コール関連
  - 通常のコール
    引数は最大6つで下記の順にレジスタにセット
    rdi, rsi, rdx, rcx, r8, r9
  - システムコール
    raxにシステムコール番号
    引数は最大6つで下記の順にレジスタにセット
      rdi, rsi, rdx, r10, r8, r9
    システムコールでは、rcx, r11の２レジスタは破壊される前提で、それらのレジスタを使う場合はsyscall前に退避する


- ラベルとcのポインタで間違ってたところ
section .data
  msg1: "hello, world", 0

と定義したmsg1は、cでいう
  char *msg2 = "hello, world";
  => "hello, world\0"の先頭アドレスを指すポインタ変数
と誤解していたが、そうではなく、
  "hello, world\0"が格納されているメモリの先頭アドレスそのもの
具体的には下記のような感じ(アドレスはサンプル)

アドレス   格納内容
0x6000c6: 'h'
0x6000c7: 'e'
0x6000c8: 'l'
0x6000c9: 'l'
0x6000ca: 'o'
0x6000cb: ','
0x6000cc: ' '
0x6000cd: 'w'
0x6000ce: 'o'
0x6000cf: 'r'
0x6000d0: 'l'
0x6000d1: 'd'
0x6000d2: '\0'
となっていた場合
アセンブラ上のmsg1は
  0x6000c6
そのものを表している
c言語のmsg2の場合は0x6000c6を指すポインタなので
メモリ上の表現としてはポインタそのもので, 8byteのリトルエンディアンとして
0x[60][00][c6]
が下位バイトから設定されているので
0x7000c6: c6
0x7000c7: 00
0x7000c8: 60
0x7000c9: 00
0x7000ca: 00
0x7000cb: 00
0x7000cc: 00
0x7000cd: 00

という値が設定された0x7000c6からの8byteに対してつけられた名前がmsg2
この違いはgdbのprint, xでよくわかって

